<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TFT Comp Tracker</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #1c1c2b;
      color: #f4f4f4;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body { display: flex; flex-direction: row; }
    #left, #right {
      width: 20%;
      padding: 0.5rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    #canvas-container { flex: 1; position: relative; }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 10;
    }
    .item {
      padding: 4px 6px;
      font-size: 0.75rem;
      border: 1px solid #444;
      margin: 2px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #333;
      transition: background-color 0.2s ease, background 0.3s ease, transform 0.2s ease;
      border-radius: 6px;
      cursor: pointer;
      position: relative;
      min-height: 30px;
    }
    .item.player {
      width: 100%;
      flex: 1;
    }
    .player-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      gap: 4px;
      margin-bottom: 16px;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.03);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
    }
    .item:hover { background-color: #444; }
    .selected {
      background-color: #555 !important;
      transform: scale(1.02);
    }
    .tier-header {
      font-weight: bold;
      margin-top: 8px;
      background: #444;
      padding: 6px;
      border-radius: 5px;
      text-align: center;
      color: #ffd700;
    }
    h3 {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #00eaff;
      border-bottom: 1px solid #555;
      padding-bottom: 0.3em;
    }
    input[type="text"], input[type="file"] {
      padding: 6px;
      border-radius: 4px;
      border: none;
      margin-top: 10px;
      background-color: #222;
      color: #fff;
      font-size: 0.9rem;
    }
    button {
      margin-top: 10px;
      padding: 8px;
      background: #00eaff;
      border: none;
      border-radius: 4px;
      color: #1c1c2b;
      font-weight: bold;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    button:hover { background: #00c4d6; }
    @media (max-width: 768px) {
  html {
    font-size: 12px;
  }
  body {
    overflow-x: auto;
    position: relative;
  }
  body::after {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 30px;
    height: 100%;
    background: linear-gradient(to right, rgba(28,28,43,1), rgba(28,28,43,0));
    pointer-events: none;
    z-index: 9999;
  }
  body::before {
    content: '';
    position: fixed;
    top: 0;
    right: 0;
    width: 30px;
    height: 100%;
    background: linear-gradient(to left, rgba(28,28,43,1), rgba(28,28,43,0));
    pointer-events: none;
    z-index: 9999;
  }
  #left, #right {
    min-width: 240px;
  }
  #canvas-container {
    min-width: 300px;
  }
  canvas {
    width: 100% !important;
    height: 100% !important;
  }
}
  body {
    overflow-x: auto;
  }
  #left, #right {
    min-width: 240px;
  }
  #canvas-container {
    min-width: 300px;
  }
  canvas {
    width: 100% !important;
    height: 100% !important;
  }
}
  #left, #right {
    min-width: 240px;
  }
  #canvas-container {
    min-width: 300px;
  }
  canvas {
    width: 100% !important;
    height: 100% !important;
  }
}
}
}
      #left, #right {
        width: 100%;
        height: auto;
        flex-direction: row;
        overflow-x: auto;
        flex-wrap: wrap;
      }
    }
    .dashed-line {
    stroke-dasharray: 6;
  }
</style>
</head>
<body>
  <div id="left" style="display: flex; flex-direction: column;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <h3 style="margin: 0;"><span style="font-size: 1.1em;">ðŸ“‹</span>Comps</h3>
    </div>
    <div id="compos"></div>
    <input type="file" id="csvInput" accept=".csv" style="margin-top: 10px;" />
  </div>
  <div id="canvas-container">
    <canvas id="lineCanvas"></canvas>
  </div>
  <div id="right">
    <div style="flex: 1; display: flex; flex-direction: column;">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <h3 style="margin: 0;"><span style="font-size: 1.1em;">ðŸ‘¤</span>Players</h3>
        <button id="toggleDoubleUp" onclick="toggleDoubleUpMode()">Double Up: OFF</button>
      </div>
      <div id="players"></div>
      <div style="margin-top: 0.5rem;">
  <button onclick="resetPlayers()" style="width: 100%;">Reset</button>
</div>
<div id="infoTableContainer"></div>
</div>
      
    </div>
<script>
    const compsContainer = document.getElementById('compos');
    const playersContainer = document.getElementById('players');
    const canvas = document.getElementById('lineCanvas');
    const ctx = canvas.getContext('2d');
    const csvInput = document.getElementById('csvInput');
    let selected = null;
    const links = [];
    const colors = ['#ff4c4c', '#4c6aff', '#4cff9a', '#ffa14c', '#c74cff', '#4cffe9', '#ffee4c'];

    function resizeCanvas() {
      canvas.width = canvas.parentElement.clientWidth;
      canvas.height = canvas.parentElement.clientHeight;
      drawLines();
      updateInfoTable();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function tryLoadDefaultCSV() {
      fetch("Comps.csv")
        .then(response => response.text())
        .then(data => loadCSVData(data));
    }

    function toggleDoubleUpMode() {
      const btn = document.getElementById('toggleDoubleUp');
      const active = document.body.classList.toggle('double-up');
      btn.textContent = `Double Up: ${active ? 'ON' : 'OFF'}`;
      resetPlayers();
    }

    function preloadPlayers() {
  const isDoubleUp = document.body.classList.contains('double-up');
  const defaultNames = getDefaultNames(isDoubleUp);
  playersContainer.innerHTML = '';

  defaultNames.forEach((name, index) => {
    const playerDiv = createPlayerDiv(name, index, isDoubleUp);
    
    if (isDoubleUp && index % 2 === 1) {
      const previous = playersContainer.lastElementChild;
      playersContainer.removeChild(previous);
      const teamIconData = getTeamIcon(index);
      const teamContainer = createTeamContainer(previous, playerDiv, teamIconData, index);
      playersContainer.appendChild(teamContainer);
    } else {
      playersContainer.appendChild(playerDiv);
    }
  });
}

// 1. Nombres por defecto
function getDefaultNames(isDoubleUp) {
  return isDoubleUp
    ? ['Team 1 - A', 'Team 1 - B', 'Team 2 - A', 'Team 2 - B', 'Team 3 - A', 'Team 3 - B', 'Team 4 - A', 'Team 4 - B']
    : ['Player A', 'Player B', 'Player C', 'Player D', 'Player E', 'Player F', 'Player G'];
}

// 2. Iconos para equipos
function getTeamIcon(index) {
  const iconOptions = [
    { name: 'Moon', color: '#c74cff', emoji: 'ðŸŒ™' },
    { name: 'Fire', color: '#ff69b4', emoji: 'ðŸ”¥' },
    { name: 'Water', color: '#4cffe9', emoji: 'ðŸ’§' },
    { name: 'Thunder', color: '#ffee4c', emoji: 'âš¡' }
  ];
  const teamIndex = Math.floor(index / 2);
  return iconOptions[teamIndex % iconOptions.length];
}

// 3. Crear contenedor para doble
function createTeamContainer(player1, player2, icon, index) {
  const container = document.createElement('div');
  container.style.display = 'flex';
  container.style.flexDirection = 'column';
  container.style.alignItems = 'center';
  container.style.border = `1px solid ${icon.color}`;
  container.style.borderRadius = '12px';
  container.style.padding = '8px';
  container.style.marginBottom = '16px';

  const iconCircle = createTeamIcon(icon, player1, player2, container);
  container.append(player1, iconCircle, player2);

  return container;
}

// 4. Crear Ã­cono central editable
function createTeamIcon(icon, player1, player2, container) {
  let currentIndex = 0;
  const iconOptions = getTeamIcon(0); // Same list as getTeamIcon

  const circle = document.createElement('div');
  Object.assign(circle.style, {
    width: '20px',
    height: '20px',
    borderRadius: '50%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontSize: '0.75rem',
    backgroundColor: '#1c1c2b',
    border: `2px solid ${icon.color}`,
    cursor: 'pointer',
    margin: '4px 0',
  });
  circle.className = 'icon-circle';
  circle.textContent = icon.emoji;
  circle.title = icon.name;

  circle.onclick = (e) => {
    e.stopPropagation();
    currentIndex = (currentIndex + 1) % 4;
    const newIcon = getTeamIcon(currentIndex * 2);
    updateIconColor(circle, newIcon, player1, player2, container);
  };

  return circle;
}

function updateIconColor(circle, icon, player1, player2, container) {
  [player1, player2].forEach(p => {
    p.dataset.color = icon.color;
    p.style.borderLeft = `10px solid ${icon.color}`;
  });
  circle.textContent = icon.emoji;
  circle.title = icon.name;
  circle.style.border = `2px solid ${icon.color}`;
  container.style.border = `1px solid ${icon.color}`;
  drawLines();
  updateInfoTable();
}

// 5. Crear div de jugador
function createPlayerDiv(name, index, isDoubleUp) {
  const div = document.createElement('div');
  div.className = 'item player';

  const span = createEditableSpan(name);
  const editIcon = createEditIcon(span);

  const color = getPlayerColor(index, isDoubleUp);
  div.dataset.color = color;
  div.style.borderLeft = `10px solid ${color}`;

  div.append(span, editIcon);
  div.onclick = () => select(div, 'player');

  return div;
}

// 6. Color asignado a jugador
function getPlayerColor(index, isDoubleUp) {
  return isDoubleUp
    ? getTeamIcon(index).color
    : colors[index % colors.length];
}

// 7. Crear span editable
function createEditableSpan(name) {
  const span = document.createElement('span');
  span.textContent = name;

  span.ondblclick = () => {
    const input = document.createElement('input');
    const original = span.textContent;

    Object.assign(input, {
      type: 'text',
      value: '',
      maxLength: 20,
    });
    Object.assign(input.style, {
      width: '100%',
      border: '1px solid #444',
      backgroundColor: 'transparent',
      color: '#fff',
      fontSize: '0.75rem',
      borderRadius: '4px',
      padding: '2px 6px',
    });

    input.onblur = () => {
      span.textContent = input.value.trim().substring(0, 20) || original;
      span.style.display = 'inline';
      input.remove();
      drawLines();
      updateInfoTable();
    };

    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        input.blur();
      } else if (e.key === 'Tab') {
        e.preventDefault();
        input.blur();
        const allPlayers = Array.from(document.querySelectorAll('.item.player'));
        const currentIndex = allPlayers.findIndex(p => p.contains(span));
        const next = allPlayers[currentIndex + 1];
        const nextSpan = next?.querySelector('span');
        if (nextSpan) nextSpan.dispatchEvent(new Event('dblclick'));
      }
    });

    span.style.display = 'none';
    span.parentElement.insertBefore(input, span);
    input.focus();
  };

  return span;
}

// 8. Crear Ã­cono de ediciÃ³n
function createEditIcon(span) {
  const icon = document.createElement('span');
  icon.textContent = 'âœŽ';
  icon.style.marginLeft = '6px';
  icon.style.cursor = 'pointer';
  icon.onclick = (e) => {
    e.stopPropagation();
    span.ondblclick();
  };
  return icon;
}
    tryLoadDefaultCSV();

document.addEventListener('DOMContentLoaded', () => {
  preloadPlayers();
});
  
var previousMultilines = {};
    function drawLines() {
  clearCanvasAndResetCompos();
  const playerLinkCounts = countLinksPerPlayer();
  updateLineStyles(playerLinkCounts);
  renderAllLines();
  updateCompoColorBars();
}

// 1. Limpiar canvas y compos
function clearCanvasAndResetCompos() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  document.querySelectorAll('.compo').forEach(c => {
    c.style.background = '';
    const oldBar = c.querySelector('.color-bar');
    if (oldBar) oldBar.remove();
  });
}

// 2. Contar links por jugador
function countLinksPerPlayer() {
  const counts = {};
  links.forEach(link => {
    const playerId = getPlayerId(link.player);
    counts[playerId] = (counts[playerId] || 0) + 1;
  });
  return counts;
}

// 3. Determinar lÃ­neas mÃºltiples y setear estilo
function updateLineStyles(playerLinkCounts) {
  links.forEach(link => {
    const playerId = getPlayerId(link.player);
    const count = playerLinkCounts[playerId];

    if (count > 1) {
      link.dashed = true;
      link.manualDashed = true;
      previousMultilines[playerId] = true;
    } else {
      if (previousMultilines[playerId]) {
        link.manualDashed = false;
      }

      if (typeof link.manualDashed === 'boolean') {
        link.dashed = link.manualDashed;
      } else {
        link.dashed = false;
        delete link.manualDashed;
      }

      previousMultilines[playerId] = false;
    }
  });
}

// 4. Dibujar lÃ­neas entre compos y jugadores
function renderAllLines() {
  links.forEach(link => {
    const start = getCenter(link.compo);
    const end = getCenter(link.player);
    const color = link.player.dataset.color || 'red';

    ctx.beginPath();
    setLineStyle(link.dashed, color);
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(end.x, end.y);
    ctx.stroke();
  });
}

// 5. Configurar estilo de lÃ­nea (dashed o normal)
function setLineStyle(dashed, color) {
  if (dashed) {
    ctx.setLineDash([6, 6]);
    ctx.globalAlpha = 0.5;
  } else {
    ctx.setLineDash([]);
    ctx.globalAlpha = 1;
  }

  ctx.strokeStyle = color;
  ctx.lineWidth = 3;
  ctx.shadowColor = color;
  ctx.shadowBlur = 4;
}

// 6. Pintar barras de colores en compos
function updateCompoColorBars() {
  const compoColorMap = {};

  links.forEach(link => {
    const compo = link.compo;
    const color = link.player.dataset.color;
    const id = compo.dataset.id;

    if (!compoColorMap[id]) {
      compoColorMap[id] = { compo, colors: new Set() };
    }

    compoColorMap[id].colors.add(color);
  });

  Object.values(compoColorMap).forEach(({ compo, colors }) => {
    const colorArray = Array.from(colors);
    const part = 100 / colorArray.length;
    const gradient = colorArray.map((color, i) => `${color} ${i * part}%, ${color} ${(i + 1) * part}%`).join(', ');

    compo.style.position = 'relative';
    const bar = compo.querySelector('.color-bar') || compo.appendChild(document.createElement('div'));
    bar.className = 'color-bar';
    Object.assign(bar.style, {
      position: 'absolute',
      top: '0', right: '0',
      width: '6px', height: '100%',
      borderRadius: '0 6px 6px 0',
      background: `linear-gradient(to bottom, ${gradient})`
    });
  });
}

// 7. Obtener identificador Ãºnico del jugador
function getPlayerId(playerElement) {
  return playerElement.querySelector('span')?.innerText || playerElement.innerText;
}

    function getCenter(el) {
      const rect = el.getBoundingClientRect();
      const container = canvas.getBoundingClientRect();
      const isPlayer = el.classList.contains('player');
      return {
        x: isPlayer ? rect.left - container.left : rect.right - container.left,
        y: rect.top + rect.height / 2 - container.top
      };
    }

    function updateInfoTable() {
      const container = document.getElementById('infoTableContainer');
      container.innerHTML = '';
      const compoMap = new Map();
      links.forEach(link => {
        const compo = link.compo;
        const estilo = compo.querySelectorAll('span')[1]?.innerText || '';
        const name = compo.querySelector('span')?.innerText || '';
        const player = link.player.querySelector('span')?.innerText || link.player.innerText;
        if (!compoMap.has(estilo)) compoMap.set(estilo, new Map());
        const entry = compoMap.get(estilo);
        if (!entry.has(name)) entry.set(name, []);
        entry.get(name).push(player);
      });
      if (compoMap.size === 0) return;
      const table = document.createElement('table');
      table.style.width = '100%';
      table.style.marginTop = '1rem';
      table.style.borderCollapse = 'collapse';
      const thead = document.createElement('thead');
      thead.innerHTML = `<tr style="background:#333;color:#ffd700">
        <th style="padding:6px;border:1px solid #555">Style</th>
        <th style="padding:6px;border:1px solid #555">Comp</th>
        <th style="padding:6px;border:1px solid #555">Players</th>
      </tr>`;
      const tbody = document.createElement('tbody');

      const sortedStyles = Array.from(compoMap.entries()).sort(([a], [b]) => {
        const aNum = parseInt(a.substr(a.length - 1)) || 0;
        const bNum = parseInt(b.substr(b.length - 1)) || 0;
        return aNum - bNum;
      });

      sortedStyles.forEach(([estilo, compMap]) => {
        const comps = Array.from(compMap.entries());
        if (comps.length > 1) {
          comps.forEach(([comp, players], index) => {
            const row = document.createElement('tr');
            if (index === 0) {
              row.innerHTML = `<td style="padding:6px;border:1px solid #555" rowspan="${comps.length}">${estilo}</td>`;
            }
            row.innerHTML += `<td style="padding:6px;border:1px solid #555">${comp}</td>
                              <td style="padding:6px;border:1px solid #555">${players.join(', ')}</td>`;
            tbody.appendChild(row);
          });
        } else {
          const [comp, players] = comps[0];
          const row = document.createElement('tr');
          row.innerHTML = `<td style="padding:6px;border:1px solid #555">${estilo}</td>
                           <td style="padding:6px;border:1px solid #555">${comp}</td>
                           <td style="padding:6px;border:1px solid #555"><table style='width: 100%; border-collapse: collapse;'>${players.map(p => `<tr><td>${p}</td></tr>`).join('')}</table></td>`;
          tbody.appendChild(row);
          
          tbody.appendChild(row);
        }
      });

      table.appendChild(thead);
      table.appendChild(tbody);
      container.appendChild(table);
    }

    function select(el, type) {
      if (selected && selected.el === el && selected.type === type) {
        el.classList.remove('selected');
        selected = null;
        return;
      }

      if (selected && selected.type !== type) {
        const a = type === 'player' ? selected.el : el;
        const b = type === 'player' ? el : selected.el;
        const exists = links.find(link => link.compo === a && link.player === b);
        if (exists) links.splice(links.indexOf(exists), 1);
        else links.push({ compo: a, player: b });
        selected.el.classList.remove('selected');
        selected = null;
        drawLines();
        updateInfoTable();
      } else {
        if (selected) selected.el.classList.remove('selected');
        selected = { el, type };
        el.classList.add('selected');
      }
    }

    function resetPlayers() {
      playersContainer.innerHTML = '';
      links.length = 0;
      drawLines();
      updateInfoTable();
      preloadPlayers();
    }
    csvInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => loadCSVData(e.target.result);
      reader.readAsText(file);
    });

function loadCSVData(csvText) {
      const lines = csvText.split(/\r?\n/);
      compsContainer.innerHTML = '';
      const tiers = { S: [], A: [], B: [], C: [] };

      lines.forEach((line, index) => {
        if (index === 0 || !line.trim()) return;
        const [comp, tier, estilo] = line.split(',').map(x => x.trim());
        if (tiers[tier]) {
          const div = document.createElement('div');
          div.className = 'item compo';
          div.dataset.id = 'compo-' + index;
          div.innerHTML = `<span>${comp}</span><span style="opacity: 0.7; font-size: 0.9em;">${estilo}</span>`;
          div.onclick = () => select(div, 'compo');
          tiers[tier].push(div);
        }
      });

      ['S', 'A', 'B', 'C'].forEach(t => {
        if (tiers[t].length > 0) {
          const header = document.createElement('div');
          header.className = 'tier-header';
          header.textContent = `Tier ${t}`;
          compsContainer.appendChild(header);
          tiers[t].forEach(div => compsContainer.appendChild(div));
        }
      });
    }

    canvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      const clickX = e.offsetX;
      const clickY = e.offsetY;
      for (let i = 0; i < links.length; i++) {
        const start = getCenter(links[i].compo);
        const end = getCenter(links[i].player);
        const dist = distanceToSegment({x: clickX, y: clickY}, start, end);
        if (dist < 6) {
          links[i].manualDashed = !(links[i].manualDashed ?? links[i].dashed);
          drawLines();
          return;
        }
      }
    });

    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      for (let i = 0; i < links.length; i++) {
        const start = getCenter(links[i].compo);
        const end = getCenter(links[i].player);
        const dist = distanceToSegment({x: clickX, y: clickY}, start, end);
        if (dist < 6) {
          links.splice(i, 1);
          drawLines();
          updateInfoTable();
          return;
        }
      }
    });

    function distanceToSegment(p, v, w) {
      const l2 = (v.x - w.x) ** 2 + (v.y - w.y) ** 2;
      if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
      let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
      t = Math.max(0, Math.min(1, t));
      return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
    }
  </script>
</body>
</html>
