<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TFT Comp Tracker</title>
  <style>
    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #1c1c2b;
      color: #f4f4f4;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      display: flex;
      flex-direction: row;
      overflow-x: auto;
    }

    #left,
    #right {
      width: 20%;
      padding: 0.5rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    #canvas-container {
      flex: 1;
      position: relative;
      min-width: 300px;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 10;
      width: 100% !important;
      height: 100% !important;
    }

    .item {
      padding: 4px 6px;
      font-size: 0.75rem;
      border: 1px solid #444;
      margin: 2px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #333;
      border-radius: 6px;
      cursor: pointer;
      position: relative;
      min-height: 30px;
      transition: background-color 0.2s ease, background 0.3s ease, transform 0.2s ease;
    }

    .item:hover {
      background-color: #444;
    }

    .item.player {
      width: 100%;
      flex: 1;
    }

    .selected {
      background-color: #555 !important;
      transform: scale(1.02);
    }

    .player-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      gap: 4px;
      margin-bottom: 16px;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.03);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
    }

    .tier-header {
      font-weight: bold;
      margin-top: 8px;
      background: #444;
      padding: 6px;
      border-radius: 5px;
      text-align: center;
      color: #ffd700;
    }

    h3 {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #00eaff;
      border-bottom: 1px solid #555;
      padding-bottom: 0.3em;
    }

    input[type="text"],
    input[type="file"] {
      padding: 6px;
      border-radius: 4px;
      border: none;
      margin-top: 10px;
      background-color: #222;
      color: #fff;
      font-size: 0.9rem;
    }

    button {
      margin-top: 10px;
      padding: 8px;
      background: #00eaff;
      border: none;
      border-radius: 4px;
      color: #1c1c2b;
      font-weight: bold;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    button:hover {
      background: #00c4d6;
    }

    .dashed-line {
      stroke-dasharray: 6;
    }

    /* Responsive layout */
    @media (max-width: 768px) {
      html {
        font-size: 12px;
      }

      body::after,
      body::before {
        content: '';
        position: fixed;
        top: 0;
        width: 30px;
        height: 100%;
        pointer-events: none;
        z-index: 9999;
      }

      body::after {
        left: 0;
        background: linear-gradient(to right, rgba(28, 28, 43, 1), rgba(28, 28, 43, 0));
      }

      body::before {
        right: 0;
        background: linear-gradient(to left, rgba(28, 28, 43, 1), rgba(28, 28, 43, 0));
      }

      #left,
      #right {
        min-width: 240px;
        width: 100%;
        flex-direction: row;
        overflow-x: auto;
        flex-wrap: wrap;
        height: auto;
      }

      #canvas-container {
        min-width: 300px;
      }
    }
  </style>
</head>

<body>
  <div id="left" style="display: flex; flex-direction: column;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <h3 style="margin: 0;"><span style="font-size: 1.1em;">ðŸ“‹</span>Comps</h3>
    </div>
    <div id="compos"></div>
    <input type="file" id="csvInput" accept=".csv" style="margin-top: 10px;" />
  </div>
  <div id="canvas-container">
    <canvas id="lineCanvas"></canvas>
  </div>
  <div id="right">
    <div style="flex: 1; display: flex; flex-direction: column;">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <h3 style="margin: 0;"><span style="font-size: 1.1em;">ðŸ‘¤</span>Players</h3>
        <button id="toggleDoubleUp" onclick="toggleDoubleUpMode()">Double Up: OFF</button>
      </div>
      <div id="players"></div>
      <div style="margin-top: 0.5rem;">
        <button onclick="resetPlayers()" style="width: 100%;">Reset</button>
      </div>
      <div id="infoTableContainer"></div>
    </div>
  </div>
  <script>
    const compsContainer = document.getElementById('compos');
    const playersContainer = document.getElementById('players');
    const canvas = document.getElementById('lineCanvas');
    const ctx = canvas.getContext('2d');
    const csvInput = document.getElementById('csvInput');
    let selected = null;
    const links = [];
    const colors = ['#ff4c4c', '#4c6aff', '#4cff9a', '#ffa14c', '#c74cff', '#4cffe9', '#ffee4c'];

    function resizeCanvas() {
      canvas.width = canvas.parentElement.clientWidth;
      canvas.height = canvas.parentElement.clientHeight;
      drawLines();
      updateInfoTable();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function tryLoadDefaultCSV() {
      fetch("Comps.csv")
        .then(response => response.text())
        .then(data => loadCSVData(data));
    }

    function toggleDoubleUpMode() {
      const btn = document.getElementById('toggleDoubleUp');
      const active = document.body.classList.toggle('double-up');
      btn.textContent = `Double Up: ${active ? 'ON' : 'OFF'}`;
      resetPlayers();
    }

    function preloadPlayers() {
      const isDoubleUp = document.body.classList.contains('double-up');
      const defaultNames = getDefaultNames(isDoubleUp);
      playersContainer.innerHTML = '';

      defaultNames.forEach((name, index) => {
        const playerDiv = createPlayerDiv(name, index, isDoubleUp);

        if (isDoubleUp && index % 2 === 1) {
          const previous = playersContainer.lastElementChild;
          playersContainer.removeChild(previous);
          const teamIconData = getTeamIcon(index);
          const teamContainer = createTeamContainer(previous, playerDiv, teamIconData, index);
          playersContainer.appendChild(teamContainer);
        } else {
          playersContainer.appendChild(playerDiv);
        }
      });
    }

    // 1. Nombres por defecto
    function getDefaultNames(isDoubleUp) {
      return isDoubleUp
        ? ['Team 1 - A', 'Team 1 - B', 'Team 2 - A', 'Team 2 - B', 'Team 3 - A', 'Team 3 - B', 'Team 4 - A', 'Team 4 - B']
        : ['Player A', 'Player B', 'Player C', 'Player D', 'Player E', 'Player F', 'Player G'];
    }

    // 2. Iconos para equipos
    function getTeamIcon(index) {
      const iconOptions = [
        { name: 'Moon', color: '#c74cff', emoji: 'ðŸŒ™' },
        { name: 'Fire', color: '#ff69b4', emoji: 'ðŸ”¥' },
        { name: 'Water', color: '#4cffe9', emoji: 'ðŸ’§' },
        { name: 'Thunder', color: '#ffee4c', emoji: 'âš¡' }
      ];
      const teamIndex = Math.floor(index / 2);
      return iconOptions[teamIndex % iconOptions.length];
    }

    // 3. Crear contenedor para doble
    function createTeamContainer(player1, player2, icon, index) {
      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.flexDirection = 'column';
      container.style.alignItems = 'center';
      container.style.border = `1px solid ${icon.color}`;
      container.style.borderRadius = '12px';
      container.style.padding = '8px';
      container.style.marginBottom = '16px';

      const iconCircle = createTeamIcon(icon, player1, player2, container);
      container.append(player1, iconCircle, player2);

      return container;
    }

    // 4. Crear Ã­cono central editable
    function createTeamIcon(icon, player1, player2, container) {
      let currentIndex = 0;
      const iconOptions = getTeamIcon(0); // Same list as getTeamIcon

      const circle = document.createElement('div');
      Object.assign(circle.style, {
        width: '20px',
        height: '20px',
        borderRadius: '50%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: '0.75rem',
        backgroundColor: '#1c1c2b',
        border: `2px solid ${icon.color}`,
        cursor: 'pointer',
        margin: '4px 0',
      });
      circle.className = 'icon-circle';
      circle.textContent = icon.emoji;
      circle.title = icon.name;

      circle.onclick = (e) => {
        e.stopPropagation();
        currentIndex = (currentIndex + 1) % 4;
        const newIcon = getTeamIcon(currentIndex * 2);
        updateIconColor(circle, newIcon, player1, player2, container);
      };

      return circle;
    }

    function updateIconColor(circle, icon, player1, player2, container) {
      [player1, player2].forEach(p => {
        p.dataset.color = icon.color;
        p.style.borderLeft = `10px solid ${icon.color}`;
      });
      circle.textContent = icon.emoji;
      circle.title = icon.name;
      circle.style.border = `2px solid ${icon.color}`;
      container.style.border = `1px solid ${icon.color}`;
      drawLines();
      updateInfoTable();
    }

    // 5. Crear div de jugador
    function createPlayerDiv(name, index, isDoubleUp) {
      const div = document.createElement('div');
      div.className = 'item player';

      const span = createEditableSpan(name);
      const editIcon = createEditIcon(span);

      const color = getPlayerColor(index, isDoubleUp);
      div.dataset.color = color;
      div.style.borderLeft = `10px solid ${color}`;

      div.append(span, editIcon);
      div.onclick = () => select(div, 'player');

      return div;
    }

    // 6. Color asignado a jugador
    function getPlayerColor(index, isDoubleUp) {
      return isDoubleUp
        ? getTeamIcon(index).color
        : colors[index % colors.length];
    }

    // 7. Crear span editable
    function createEditableSpan(name) {
      const span = document.createElement('span');
      span.textContent = name;

      span.ondblclick = () => {
        const input = document.createElement('input');
        const original = span.textContent;

        Object.assign(input, {
          type: 'text',
          value: '',
          maxLength: 20,
        });
        Object.assign(input.style, {
          width: '100%',
          border: '1px solid #444',
          backgroundColor: 'transparent',
          color: '#fff',
          fontSize: '0.75rem',
          borderRadius: '4px',
          padding: '2px 6px',
        });

        input.onblur = () => {
          span.textContent = input.value.trim().substring(0, 20) || original;
          span.style.display = 'inline';
          input.remove();
          drawLines();
          updateInfoTable();
        };

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            input.blur();
          } else if (e.key === 'Tab') {
            e.preventDefault();
            input.blur();
            const allPlayers = Array.from(document.querySelectorAll('.item.player'));
            const currentIndex = allPlayers.findIndex(p => p.contains(span));
            const next = allPlayers[currentIndex + 1];
            const nextSpan = next?.querySelector('span');
            if (nextSpan) nextSpan.dispatchEvent(new Event('dblclick'));
          }
        });

        span.style.display = 'none';
        span.parentElement.insertBefore(input, span);
        input.focus();
      };

      return span;
    }

    // 8. Crear Ã­cono de ediciÃ³n
    function createEditIcon(span) {
      const icon = document.createElement('span');
      icon.textContent = 'âœŽ';
      icon.style.marginLeft = '6px';
      icon.style.cursor = 'pointer';
      icon.onclick = (e) => {
        e.stopPropagation();
        span.ondblclick();
      };
      return icon;
    }
    tryLoadDefaultCSV();

    document.addEventListener('DOMContentLoaded', () => {
      preloadPlayers();
    });

    var previousMultilines = {};
    function drawLines() {
      clearCanvasAndResetCompos();
      const playerLinkCounts = countLinksPerPlayer();
      updateLineStyles(playerLinkCounts);
      renderAllLines();
      updateCompoColorBars();
    }

    // 1. Limpiar canvas y compos
    function clearCanvasAndResetCompos() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      document.querySelectorAll('.compo').forEach(c => {
        c.style.background = '';
        const oldBar = c.querySelector('.color-bar');
        if (oldBar) oldBar.remove();
      });
    }

    // 2. Contar links por jugador
    function countLinksPerPlayer() {
      const counts = {};
      links.forEach(link => {
        const playerId = getPlayerId(link.player);
        counts[playerId] = (counts[playerId] || 0) + 1;
      });
      return counts;
    }

    // 3. Determinar lÃ­neas mÃºltiples y setear estilo
    function updateLineStyles(playerLinkCounts) {
      links.forEach(link => {
        const playerId = getPlayerId(link.player);
        const count = playerLinkCounts[playerId];

        if (count > 1) {
          link.dashed = true;
          link.manualDashed = true;
          previousMultilines[playerId] = true;
        } else {
          if (previousMultilines[playerId]) {
            link.manualDashed = false;
          }

          if (typeof link.manualDashed === 'boolean') {
            link.dashed = link.manualDashed;
          } else {
            link.dashed = false;
            delete link.manualDashed;
          }

          previousMultilines[playerId] = false;
        }
      });
    }

    // 4. Dibujar lÃ­neas entre compos y jugadores
    function renderAllLines() {
      links.forEach(link => {
        const start = getCenter(link.compo);
        const end = getCenter(link.player);
        const color = link.player.dataset.color || 'red';

        ctx.beginPath();
        setLineStyle(link.dashed, color);
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
      });
    }

    // 5. Configurar estilo de lÃ­nea (dashed o normal)
    function setLineStyle(dashed, color) {
      if (dashed) {
        ctx.setLineDash([6, 6]);
        ctx.globalAlpha = 0.5;
      } else {
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
      }

      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.shadowColor = color;
      ctx.shadowBlur = 4;
    }

    // 6. Pintar barras de colores en compos
    function updateCompoColorBars() {
      const compoColorMap = {};

      links.forEach(link => {
        const compo = link.compo;
        const color = link.player.dataset.color;
        const id = compo.dataset.id;

        if (!compoColorMap[id]) {
          compoColorMap[id] = { compo, colors: new Set() };
        }

        compoColorMap[id].colors.add(color);
      });

      Object.values(compoColorMap).forEach(({ compo, colors }) => {
        const colorArray = Array.from(colors);
        const part = 100 / colorArray.length;
        const gradient = colorArray.map((color, i) => `${color} ${i * part}%, ${color} ${(i + 1) * part}%`).join(', ');

        compo.style.position = 'relative';
        const bar = compo.querySelector('.color-bar') || compo.appendChild(document.createElement('div'));
        bar.className = 'color-bar';
        Object.assign(bar.style, {
          position: 'absolute',
          top: '0', right: '0',
          width: '6px', height: '100%',
          borderRadius: '0 6px 6px 0',
          background: `linear-gradient(to bottom, ${gradient})`
        });
      });
    }

    // 7. Obtener identificador Ãºnico del jugador
    function getPlayerId(playerElement) {
      return playerElement.querySelector('span')?.innerText || playerElement.innerText;
    }

    function getCenter(el) {
      const rect = el.getBoundingClientRect();
      const container = canvas.getBoundingClientRect();
      const isPlayer = el.classList.contains('player');
      return {
        x: isPlayer ? rect.left - container.left : rect.right - container.left,
        y: rect.top + rect.height / 2 - container.top
      };
    }

    function updateInfoTable() {
      const container = document.getElementById('infoTableContainer');
      container.innerHTML = '';

      const compoMap = buildCompoMap();
      if (compoMap.size === 0) return;

      const table = createInfoTable(compoMap);
      container.appendChild(table);
    }

    // 1. Agrupar datos de links en Map(style -> Map(comp -> [players]))
    function buildCompoMap() {
      const map = new Map();

      links.forEach(link => {
        const compo = link.compo;
        const estilo = compo.querySelectorAll('span')[1]?.innerText || '';
        const compName = compo.querySelector('span')?.innerText || '';
        const playerName = link.player.querySelector('span')?.innerText || link.player.innerText;

        if (!map.has(estilo)) map.set(estilo, new Map());
        const compMap = map.get(estilo);
        if (!compMap.has(compName)) compMap.set(compName, []);
        compMap.get(compName).push(playerName);
      });

      return map;
    }

    // 2. Crear tabla HTML desde compoMap
    function createInfoTable(compoMap) {
      const table = document.createElement('table');
      Object.assign(table.style, {
        width: '100%',
        marginTop: '1rem',
        borderCollapse: 'collapse'
      });

      table.appendChild(createInfoTableHeader());

      const tbody = document.createElement('tbody');
      const sortedStyles = sortCompoMapByStyleNumber(compoMap);

      sortedStyles.forEach(([style, compsMap]) => {
        const comps = Array.from(compsMap.entries());

        comps.forEach(([comp, players], index) => {
          const row = document.createElement('tr');

          // Insert style cell with rowspan
          if (index === 0) {
            const tdStyle = createTableCell(style, comps.length);
            row.appendChild(tdStyle);
          }

          const tdComp = createTableCell(comp);
          const tdPlayers = createPlayerCell(players);

          row.appendChild(tdComp);
          row.appendChild(tdPlayers);
          tbody.appendChild(row);
        });
      });

      table.appendChild(tbody);
      return table;
    }

    // 3. Crear encabezado de tabla
    function createInfoTableHeader() {
      const thead = document.createElement('thead');
      thead.innerHTML = `
    <tr style="background:#333;color:#ffd700">
      <th style="padding:6px;border:1px solid #555">Style</th>
      <th style="padding:6px;border:1px solid #555">Comp</th>
      <th style="padding:6px;border:1px solid #555">Players</th>
    </tr>`;
      return thead;
    }

    // 4. Crear celda de texto (con rowspan opcional)
    function createTableCell(text, rowspan) {
      const td = document.createElement('td');
      td.textContent = text;
      td.style.padding = '6px';
      td.style.border = '1px solid #555';
      if (rowspan) td.rowSpan = rowspan;
      return td;
    }

    // 5. Crear celda de jugadores (como lista o tabla interna)
    function createPlayerCell(players) {
      const td = document.createElement('td');
      td.style.padding = '6px';
      td.style.border = '1px solid #555';

      if (players.length === 1) {
        td.textContent = players[0];
      } else {
        const innerTable = document.createElement('table');
        innerTable.style.width = '100%';
        innerTable.style.borderCollapse = 'collapse';
        players.forEach(p => {
          const row = document.createElement('tr');
          const cell = document.createElement('td');
          cell.textContent = p;
          row.appendChild(cell);
          innerTable.appendChild(row);
        });
        td.appendChild(innerTable);
      }

      return td;
    }

    // 6. Ordenar estilos alfabÃ©ticamente por nÃºmero final
    function sortCompoMapByStyleNumber(compoMap) {
      return Array.from(compoMap.entries()).sort(([a], [b]) => {
        const aNum = parseInt(a.match(/\d+$/)?.[0]) || 0;
        const bNum = parseInt(b.match(/\d+$/)?.[0]) || 0;
        return aNum - bNum;
      });
    }

    function select(el, type) {
      if (selected && selected.el === el && selected.type === type) {
        el.classList.remove('selected');
        selected = null;
        return;
      }

      if (selected && selected.type !== type) {
        const a = type === 'player' ? selected.el : el;
        const b = type === 'player' ? el : selected.el;
        const exists = links.find(link => link.compo === a && link.player === b);
        if (exists) links.splice(links.indexOf(exists), 1);
        else links.push({ compo: a, player: b });
        selected.el.classList.remove('selected');
        selected = null;
        drawLines();
        updateInfoTable();
      } else {
        if (selected) selected.el.classList.remove('selected');
        selected = { el, type };
        el.classList.add('selected');
      }
    }

    function resetPlayers() {
      playersContainer.innerHTML = '';
      links.length = 0;
      drawLines();
      updateInfoTable();
      preloadPlayers();
    }
    csvInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => loadCSVData(e.target.result);
      reader.readAsText(file);
    });

    function loadCSVData(csvText) {
      const lines = csvText.split(/\r?\n/);
      compsContainer.innerHTML = '';
      const tiers = { S: [], A: [], B: [], C: [] };

      lines.forEach((line, index) => {
        if (index === 0 || !line.trim()) return;
        const [comp, tier, estilo] = line.split(',').map(x => x.trim());
        if (tiers[tier]) {
          const div = document.createElement('div');
          div.className = 'item compo';
          div.dataset.id = 'compo-' + index;
          div.innerHTML = `<span>${comp}</span><span style="opacity: 0.7; font-size: 0.9em;">${estilo}</span>`;
          div.onclick = () => select(div, 'compo');
          tiers[tier].push(div);
        }
      });

      ['S', 'A', 'B', 'C'].forEach(t => {
        if (tiers[t].length > 0) {
          const header = document.createElement('div');
          header.className = 'tier-header';
          header.textContent = `Tier ${t}`;
          compsContainer.appendChild(header);
          tiers[t].forEach(div => compsContainer.appendChild(div));
        }
      });
    }

    canvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      const clickX = e.offsetX;
      const clickY = e.offsetY;
      for (let i = 0; i < links.length; i++) {
        const start = getCenter(links[i].compo);
        const end = getCenter(links[i].player);
        const dist = distanceToSegment({ x: clickX, y: clickY }, start, end);
        if (dist < 6) {
          links[i].manualDashed = !(links[i].manualDashed ?? links[i].dashed);
          drawLines();
          return;
        }
      }
    });

    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      for (let i = 0; i < links.length; i++) {
        const start = getCenter(links[i].compo);
        const end = getCenter(links[i].player);
        const dist = distanceToSegment({ x: clickX, y: clickY }, start, end);
        if (dist < 6) {
          links.splice(i, 1);
          drawLines();
          updateInfoTable();
          return;
        }
      }
    });

    function distanceToSegment(p, v, w) {
      const l2 = (v.x - w.x) ** 2 + (v.y - w.y) ** 2;
      if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
      let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
      t = Math.max(0, Math.min(1, t));
      return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
    }
  </script>
</body>

</html>